- photos_per_request = Api::V1::PicsController::PAGESIZE

:javascript

  $('#photobar').css({width: '200000px', 'background-color': 'green'});

  var language = 'ia';

  var endGap = 400; // pixels
  var fullThumbSize = 50;
  var halfThumbSize = fullThumbSize / 2;
  var borderWidth = 2; // px
  var photoWidth = fullThumbSize + (2 * borderWidth); // pixels (borderWidth px on each side)

  var handleRadius = 5; // px
  var handleWidth = 2 * handleRadius; // px
  var magicAdjustmentFactor = 8

  var mugmarkerServices = angular.module('mugmarkerServices', ['ngResource']);

  mugmarkerServices.factory('Photo', ['$resource',
                                      '$http',
                                      function($resource, $http)
                                      { // TODO HOW DO YOU DEAL WITH ERRORS?
                                        return $resource('/api/v1/pics/:id.json', 
                                                         {a_id: 1 }, 
                                                         {
                                                            update: 
                                                            {
                                                              method: "PUT",
                                                              params: {id: "@id"}
                                                            }
                                                          } 
                                        );
                                      }
                                     ]
  );
  mugmarkerServices.factory('Face',  ['$resource',
                                      '$http',
                                      function($resource, $http)
                                      { // TODO HOW DO YOU DEAL WITH ERRORS?
                                        return $resource('/api/v1/faces/:id.json', 
                                                         {a_id: 1}, 
                                                         {
                                                            update: 
                                                            {
                                                              method: "PUT",
                                                              params: {id: "@id"} // The face Id
                                                            }
                                                          } 
                                        );
                                      }
                                     ]
  );
  var app = angular.module('mugmarker', ['ui.router', 'mugmarkerServices']);

  // Configure the router (ui-router)
  app.config(['$stateProvider', '$urlRouterProvider', function($stateProvider, $urlRouterProvider) {
    $urlRouterProvider.otherwise('/');
    $stateProvider
      .state('edit',
              {
                url:'/edit/:id',
                views:
                {
                  display:
                  {
                    templateUrl: '/templates/photo.html',
                    controller: 'PhotoController'
                  }

                }
             })
      .state('detail', 
              {
                url:'/detail/:id',
                views:
                {
                  display:
                  {
                    templateUrl: '/templates/detail.html',
                    controller: 'DetailController'
                  }

                }
             })
  }]);


  app.factory('translations', function() 
  {
    var translations = { en: { confirmDeleteFace: 'Do you really want to delete this face?',
                               deleteFace: 'Delete face',
                               detailsButton: 'Details', 
                               photoButton: 'Photo', 
                               markPhoto: 'Mark this photo for later attention',
                               restoreButton: 'Restore Faces',
                               tryAgain: 'An error occurred. Please try again.' }, 
                         ia: { confirmDeleteFace: 'oDay youway eallyray antway otay eleteday isthay acefay?',
                               deleteFace: 'eleteDay acefay',
                               detailsButton: 'etailsDay', 
                               photoButton: 'otoPhay',
                               markPhoto: 'arkMay isthay otophay orfay aterlay attentionway',
                               restoreButton: 'estoreRay acesFay',
                               tryAgain: 'Anway errorway occurredway. easePlay ytray againway.' } }
    var language = 'ia';

    return {
      setLanguage: function(newLang)
      {
        language = newLang;
      },
      translate: function(key)
      {
        return translations[language][key];
      }
    };
  });

  // mmMovable: not really draggable (no drop needed), with a containment rectangle specified
  // derived from https://docs.angularjs.org/guide/directive (see "Creating a Directive that Adds Event Listeners")
  
  app.directive('mmMovable', ['$document', function($document) {
    return {
      scope:
      {
        face: '=mmMovable',
        behavior: '@mmMovableBehavior',
        containment: '=mmMovableContainment',
        photo: '=mmMovablePhoto'
      },
      link: function(scope, element, attr, ctrl) 
      {
        var ele = element[0]; // extract the actual element

        var top = scope.containment.top - (ele.offsetHeight / 2);
        var bottom = scope.containment.top + scope.containment.height - (ele.offsetHeight / 2);

        var left = scope.containment.left - (ele.offsetWidth / 2);
        var right = scope.containment.left + scope.containment.width - (ele.offsetWidth / 2);
        
        var startX = 0, startY = 0;
        var x = scope.face.h - magicAdjustmentFactor;
        var y = scope.face.w - magicAdjustmentFactor;

        var p = scope.photo; 
        element.on('mousedown', function(event) {
          event.preventDefault(); // Prevent default dragging of selected content
          event.stopPropagation(); // The handle is nested in the frame, so it fires 2x
          if (scope.face.manual) // Otherwise the "move" option remains available to all faces
          {
            startX = scope.photo.unscaled(event.pageX) - x;
            startY = scope.photo.unscaled(event.pageY)- y;
            $document.on('mousemove', mousemove);
            $document.on('mouseup', mouseup);           
          }
        });

        function mousemove(event) {
          var deltaX = x;
          var deltaY = y;
          var unscaledX = scope.photo.unscaled(event.pageX);
          var unscaledY = scope.photo.unscaled(event.pageY);
          x = Math.min(Math.max(unscaledX - startX, left), right);
          y = Math.min(Math.max(unscaledY - startY, top), bottom);
          deltaX = x - deltaX;
          deltaY = y - deltaY;

          if (scope.behavior == 'resize')
          {
            scope.face.x -= deltaX;
            scope.face.y -= deltaY;
            scope.face.h += deltaY * 2;
            scope.face.w += deltaX * 2;
          }
          else if (scope.behavior == 'move')
          {
            scope.face.x += deltaX;
            scope.face.y += deltaY;
          }

          scope.$apply();
        }

        function mouseup() {
          $document.off('mousemove', mousemove);
          $document.off('mouseup', mouseup);
        }
      }
    };
  }]);


  /*

    // ***** Everything from this point down has to do with resizing/moving faces ***** //
    // ***** Only faces that were manually created are allowed to perform these functions ***** //

    var faceOriginalW;
    var faceOriginalH;
    var relPos;

    var setRelPos = function()
    {
      faceOriginalW = Math.floor(0.5 + $(face).width()); // round it up/down
      faceOriginalH = Math.floor(0.5 + $(face).height()); // round it up/down
      facePosition = $(face).position();
      relPos = {top: Math.floor(0.5 + facePosition.top) + faceOriginalH - handleRadius + borderWidth, 
                left: Math.floor(0.5 + facePosition.left) + faceOriginalW - handleRadius + borderWidth};
    }

    setRelPos();

    var setHandleContainmentRectangle = function(target)
    {
      var faceCenterX = containerPosition.left + facePosition.left + (faceOriginalW / 2);
      var faceCenterY = containerPosition.top + facePosition.top + (faceOriginalH / 2);
      var distanceToEachEdge = [faceCenterX - containerPosition.left, 
                                containerPosition.left + $('#photo-container > img').width() - faceCenterX];
      var maxDeltaX = Math.min.apply(null, distanceToEachEdge);
      distanceToEachEdge = [faceCenterY - containerPosition.top, 
                            containerPosition.top + $('#photo-container > img').height() - faceCenterY];
      var maxDeltaY = Math.min.apply(null, distanceToEachEdge);
      var handleContainment = [faceCenterX, // Do not adjust because handle is positioned from its left edge
                               faceCenterY,
                               faceCenterX + maxDeltaX - handleWidth,
                               faceCenterY + maxDeltaY - handleWidth
                              ];
      $(target).draggable('option', 'containment', handleContainment); 
    }
    var setFaceContainmentRectangle = function(target)
    {
      var faceContainmentRectangle = [containerPosition.left + handleRadius, 
                                      containerPosition.top + handleRadius,
                                      containerPosition.left + $('#photo-container > img').width() -
                                        ($(face).width() + handleWidth),
                                      containerPosition.top + $('#photo-container > img').height() -
                                        ($(face).height() + handleWidth)];
      $(target).draggable('option', 'containment', faceContainmentRectangle)
    }
  */
  app.controller('DetailController', ['$scope', '$stateParams', '$http', 'translations', 
                                      function($scope, $stateParams, $http, translations)
                                      {
                                        $http.get('#{details_api_v1_pics_path(format: :json)}?a_id=1&id=' + $stateParams.id )
                                             .success(function(response)
                                                      {
                                                        $scope.photo = {id: $stateParams.id}; // To support navigation in partial
                                                        $scope.details = response;
                                                      })
                                        $scope.detailsAsJson = function()
                                        {
                                          return angular.toJson($scope.details, true);
                                        }
                                        $scope.xlate = translations.translate;
                                      }
  ]);



  (function() {

    var id_counter = 1;
    Object.defineProperty(Object.prototype, "__uniqueId", {
        writable: true
    });
    Object.defineProperty(Object.prototype, "mmuid", {
        get: function() {
            if (this.__uniqueId == undefined)
                this.__uniqueId = id_counter++;
            return this.__uniqueId;
        }
    });
  })();

  var timers = {};
  debounce = function(obj, milliseconds, func)
  {
    var args = arguments;
    clearTimeout(timers[obj.mmuid]);
    timers[obj.mmuid] = setTimeout(function()
                             {
                               func.apply(obj, args);
                               timers[obj.mmuid] = null;
                             }, 
                             milliseconds);
  }

  app.controller('PhotoController', ['$scope', '$stateParams', '$http', 'Photo', 'Face', 'translations', 

                                      function($scope, $stateParams, $http, Photo, Face, translations)
                                      {
                                        var maxDim = 500; // pixels
                                        var scaleFactor; // updated when the Photo object is loaded
                                        var defineScaledMethods = function(whichFace)
                                        {
                                          whichFace.scaledX = function() {return (this.x * scaleFactor) + 'px';};
                                          whichFace.scaledY = function() {return (this.y * scaleFactor) + 'px';};
                                          whichFace.scaledW = function() {return (this.w * scaleFactor) + 'px';};
                                          whichFace.scaledH = function() {return (this.h * scaleFactor) + 'px';};
                                          // 8 in the following has to do with the diameter of the handle
                                          whichFace.handleY = function() {return (this.h * scaleFactor - 8) + 'px';};
                                          whichFace.handleX = function() {return (this.w * scaleFactor - 8) + 'px';};
                                          whichFace.photo_id = photo.id;
                                        };

                                        var photo = Photo.get({ id: $stateParams.id }, function() {
                                          scaleFactor = maxDim / Math.max(photo.width, photo.height);
                                          photo.unscaled = function(rawValue) {return Math.floor(rawValue / scaleFactor);}
                                          photo.mmuid; // Assign a unique ID so the first debounce doesn't trigger an update
                                          angular.forEach(photo.faces, defineScaledMethods);                              
                                          $scope.photo = photo;
                                          $scope.faces = photo.faces;
                                          angular.forEach(photo.faces, function(value, key, obj) 
                                                                       {
                                                                         $scope.$watch('faces[' + key + ']', report, true); 
                                                                       });
                                          photo.faces = undefined;
                                          $scope.$watch('photo', report, true);
                                        }); // get() returns a single photo
                                       
                                      /*  var photos = Photo.query(function() {
                                            console.log(photos);
                                          }); //query() returns all the entries
                                       */
                                       
                                      /* $scope.photo.data = 'some data'; */
                                       
                                       /* Photo.save($scope.photo, function() {
                                          //data saved. do something here.
                                        }); //saves an photo. Assuming $scope.photo is the Photo object  
                                      */

                                        $scope.addFaceAt = function(x, y)
                                        {
                                          // We must convert the coordinates back to that of the original photo
                                          var unscaledX = $scope.photo.unscaled(x);
                                          var unscaledY = $scope.photo.unscaled(y);

                                          // We calculate the average width and height of visible faces
                                          var sumW = 0;
                                          var sumH = 0;
                                          var meanWidth = 0;
                                          var meanHeight = 0;
                                          var minFaceDimension = 50; // Pixels
                                          var n = 0;
                                          for (var i = 0; i < $scope.faces.length; i++)
                                          {
                                            // Skip the deleted faces
                                            if (!$scope.faces[i].deleted)
                                            {
                                              sumW += $scope.faces[i].w;
                                              sumH += $scope.faces[i].h;
                                              n += 1;
                                            }
                                          }
                                          if (n > 0)
                                          {
                                            meanWidth = sumW / n;
                                            meanHeight = sumH / n;
                                          }

                                          meanWidth = Math.max(meanWidth, minFaceDimension);
                                          meanHeight = Math.max(meanHeight, minFaceDimension);

                                          var face = {x: unscaledX - (meanWidth / 2), 
                                                      y: unscaledY - (meanHeight / 2), 
                                                      w: meanWidth, 
                                                      h: meanHeight, 
                                                      photo_id: $scope.photo.id,
                                                      deleted: false,
                                                      manual: true, 
                                                      text: null,
                                                      id: null,
                                                    };
                                          defineScaledMethods(face);
                                          if ((0 < face.x) && (face.x < ($scope.photo.width - (meanWidth / 2))) &&
                                              (0 < face.y) && (face.y < ($scope.photo.height - (meanHeight / 2))))
                                          {
                                            $scope.faces.push(face);
                                            Face.save(face);
                                          }
                                        }
                                        $scope.confirmFaceDelection = function(face)
                                                                      {
                                                                        if (confirm($scope.xlate('confirmDeleteFace')))
                                                                        {
                                                                          face.deleted = true;
                                                                          $scope.setHoverFace(null);
                                                                        }
                                                                      }
                                        $scope.handleVisible = function()
                                                               {
                                                                 return true;
                                                               }
                                        $scope.setHoverFace = function(face)
                                                              {
                                                                $scope.hoverFace = face;
                                                              }
                                        $scope.setHoverFace(null);
                                        $scope.xlate = translations.translate;
                                        var updatePhoto = function(target) 
                                                          {
                                                            console.log(new Date().getSeconds(), target);
                                                            Photo.update(target, function(a, b, c)
                                                              {
                                                                console.log('abc', a, b, c);
                                                              });
                                                          };
                                        var report = function(newValue, oldValue)
                                        {
                                          if (newValue !== oldValue)
                                          {
                                            debounce(newValue, 1000, updatePhoto);
                                          }
                                        }
                                      }
                                    ]
  );

  app.controller('NamesController', [ '$scope', '$http', 'translations', 
                                      function($scope, $http, translations)
                                      {
                                        $http.get("#{api_v1_names_path}.json?a_id=1")
                                             .success(function(response)
                                                      { 
                                                         $scope.names = response;
                                                      }
                                             );
                                          $scope.setSelectedName = function(name)
                                                                   {
                                                                     selectedName = name
                                                                   }
                                          $scope.xlate = translations.translate;
                                      }
                                    ]
  );

  app.filter('matchesNameNeedle', function ()
                                  {
                                    return function (name) {
                                        return name.publicName.toUpperCase();
                                    };
                                  }
  );


-# // ***** This is all the markup for the page *****

 
.row
  %p#notice= notice

.row#photobar-container
  #photobar
  
%div{'ui-view' => 'display'}

%div{'ng-controller' => 'NamesController'}
  #name{style: "display: none;"}
    %form#name-entry-form{novalidate: :novalidate, :style => "width: 20em;"}
      .input-group
        %input#name-entry-box.form-control.input-sm{'ng-model' => "nameNeedle",
                                                    :placeholder => "Enter Name",
                                                    :type => "text"}/
        %span#name-clear.input-group-addon.glyphicon.glyphicon-remove-circle{"aria-label" => "Clear the name input field", |
                                                                             :style => "top: 0;"}
      #names-container{:style => "width: 20em; max-height: 170px; display: block;"}
        .row{'ng-repeat' => 'name in names', 
             'ng-click' => 'setSelectedName(name)',
             'ng-show' => 'name.publicName.toLowerCase().indexOf(nameNeedle.toLowerCase()) > -1'}
          .col-xs-1{:style => "padding-left: 4px; min-width: 38px; "}
            %img{:src => "https://upload.wikimedia.org/wikipedia/en/6/6f/Smiley_Face.png", :style => "height:30px"}/
          .col-xs-10.ellipsis{:style => "padding: 0;"}
            {{ name.publicName }}
            .name-note
              {{ name.note ? name.note : ' ' }} {{name.publicName.toLowerCase().indexOf(nameNeedle.toLowerCase()) > -1 }}

:javascript

  // ***** All the ISOLATED jQuery-dependent stuff that has to come after jQuery is loaded
  //       and the DOM is ready. Hence it is at the end, isolated. Move this to jqLite.    *****
  var i2x = function(i) { return endGap + (i * photoWidth) };
  var x2i = function(x) { return Math.floor(Math.max(0, x - endGap) / photoWidth) };
  
  // This is the number of requests to make. It relies on knowing how many total photos there are,
  // so we scale it back after the first request. It starts big in case the window is super-wide.
  var photosPerRequest = #{photos_per_request};
  var photobarContainerWidth = document.getElementById('photobar-container').offsetWidth;
  var bunchedRequestCount = (photobarContainerWidth / (photosPerRequest * photoWidth)) + 1;

      // TODO  There was code here to make sure it doesn't show the same photo twice:
      //  <% if ($('.photothumb[phid=' + photo.get('id') + ']').length == 0) { %>

  var jqLite = angular.element;
  var jqLiteFind = function(sel) { angular.element(document.querySelector(sel)) };
  var getNavImages = function(n)
  {
    $.ajax({
      url: 'http://localhost:3000/api/v1/pics.json?a_id=1&n=' + n,
      success: function(response)
               {
                 document.getElementById('photobar').style.width = i2x(response.totalPhotos) + 'px';
                 for (var i = 0; i < response.photos.length ; i++) 
                 {
                   var photo = response.photos[i];
                   var match = document.getElementById('thumb_' + photo.id);
                   if (!match)
                   {
                     $('<div id="thumb_' + photo.id + '" ' +
                                 'class="photothumb unselected" ' +
                                 'style="left:' + i2x(photo.index) + 'px;" '  +
                                 'data-id="' + photo.id + '"><img src="'+ photo.thumb + '" /></div>')
                       .appendTo('#photobar');
                   }
                 }
               },
        error: function(jqXhr, status) {
            alert('An unexpected error occurred (' + status + '). Please try again.');
          },
        dataType: 'json'
    });
  }
  
  var scrollingDone = function() {
    var x = document.getElementById('photobar-container').scrollLeft;
    n = Math.floor(x2i(x) / photosPerRequest); // The first bunch to be requested
    for (var j = 0; j < bunchedRequestCount; j++)
    {
      getNavImages(n + j);
    }
  };
  scrollingDone();
  $('#photobar-container').on('scroll', function() {debounce(this, 250, scrollingDone)} );

  $('#photobar').on('mouseover', '.photothumb', function() {
      $(this).css({ top: $(this).position().top - halfThumbSize,
                    left: $(this).position().left - halfThumbSize
                  });
  });
  $('#photobar').on('mouseout', '.photothumb', function() {
    $(this).css({ top:  $(this).position().top + halfThumbSize,
                  left: $(this).position().left + halfThumbSize
                 });
  });
  $('#photobar').on('click', '.photothumb', function() {
    $('#photobar > .selected').removeClass('selected').addClass('unselected');
    // TODO Fill in with the image you have. Requires knowing the AR of the photo 
    //$('#photo-container').html('&nbsp;').css({'background-image': $(this).css('background-image'), 
    //                                            "background-size": "contain", 
    //                                            "background-color": "white"})
    //                                      .css(parseFloat($(this).attr("ar")) > 1.0 ? 'width' : 'height', "500px");
    $(this).removeClass('unselected').addClass('selected');
    window.location = "#/edit/" + $(this).data('id');
  });

