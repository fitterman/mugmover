:javascript

  $('#photobar').css({width: '200000px', 'background-color': 'green'});

  var language = 'ia';

  var endGap = 400; // pixels
  var fullThumbSize = 50;
  var halfThumbSize = fullThumbSize / 2;
  var borderWidth = 1; // px
  var photoWidth = fullThumbSize + (2 * borderWidth); // pixels (borderWidth px on each side)

  // TODO Get these two aligned.
  var minFaceDimension = 20; // Pixels TODO Scale to photo
  var minFaceDimensionPixels = 24; // This is what the UI shows (it actually includes 2xborderWidth!)

  var handleRadius = 5; // px
  var handleWidth = 2 * handleRadius; // px

  var faceNameHideTimeout = 1200

  var mugmarkerServices = angular.module('mugmarkerServices', ['ngResource']);

  mugmarkerServices.factory('Photo',
                            ['$resource',
                              function($resource)
                              {
                                return $resource('/api/v1/photos/:id.json', 
                                                 {a_id: 1 }, 
                                                 {
                                                    update: 
                                                    {
                                                      method: "PUT",
                                                      params: {id: "@id"}
                                                    }
                                                  } 
                                );
                              }
                             ]
  );
  mugmarkerServices.factory('Face',
                            ['$resource',
                              function($resource)
                              {
                                return $resource('/api/v1/faces/:id.json', 
                                                 {a_id: 1}, 
                                                 {
                                                    update: 
                                                    {
                                                      method: "PUT",
                                                      params: {id: "@id"} // The face Id
                                                    },
                                                    restore: 
                                                    {
                                                      url: "/api/v1/faces/:id/restore.json",
                                                      method: "POST",
                                                      params: {id: "@id"} // The face Id
                                                    }

                                                  } 
                                );
                              }
                             ]
  );
  mugmarkerServices.service('NameToPhotoGlue',  
                            [function()
                              {
                                // This just transfers the scope of the photo
                                this.setPhotoScope = function(photoScope)
                                {
                                  this.photoScope = photoScope;
                                }

                                // This just sets the names in this context
                                this.setNamesIndex = function(namesIndex)
                                {
                                  this.names = namesIndex;
                                }

                                // This translates a face ID to a name
                                this.getPrivateName = function(namedFaceId)
                                {
                                  face = this.names[namedFaceId];
                                  return face ? face.privateName : undefined;
                                }

                                this.mergeNewFacedata = function(newNames)
                                {
                                  for (var id in newNames)
                                  {
                                    this.names[id] = newNames[id];
                                  }
                                }

                                // This records a particular face and clears the selected name
                                this.setFace = function(face)
                                {
                                  this.selectedFace = face;
                                  this.selectedName = null;
                                }

                                // This method accepts a name, which will be sent to the
                                // server to create a new record, and that record will 
                                // then be associated with the current face frame.
                                this.applyNewName = function(nameNeedle)
                                {
                                  this.photoScope.updateFace(this.selectedFace, nameNeedle);
                                }

                                // This is called after a name in the list is clicked,
                                // setting the name ID for the face that was just clicked
                                this.setName = function(name)
                                {
                                  this.photoScope.setHoverFace(this.selectedFace);
                                  this.selectedFace.namedFaceId = name.id;
                                }

                                // 
                              }
                             ]
  );
  var app = angular.module('mugmarker', ['ui.router', 'mugmarkerServices']);

  // Configure the router (ui-router)
  app.config(['$stateProvider', '$urlRouterProvider', 
    function($stateProvider, $urlRouterProvider)
    {
      $urlRouterProvider.otherwise('/');
      $stateProvider
        .state('edit',
                {
                  url:'/photo/edit/:id',
                  views:
                  {
                    display:
                    {
                      templateUrl: '/templates/photo.html',
                      controller: 'PhotoController'
                    }

                  }
               })
        .state('detail', 
                {
                  url:'/photo/detail/:id',
                  views:
                  {
                    display:
                    {
                      templateUrl: '/templates/detail.html',
                      controller: 'DetailController'
                    }

                  }
               })
    }
  ]);


  app.service('translations', function() 
  {
    var translations = 
    { 
      en: { 
            confirmDeleteFace: 'Do you really want to delete this frame?',
            deleteFace: 'Delete frame',
            detailsButton: 'Details',
            errorApplyingChange: 'An error occurred and the change you made could not be saved.',
            markPhoto: 'Mark or unmark this photo for later attention',
            photoButton: 'Photo', 
            restoreButton: 'Restore Frames',
            tryAgain: 'An error occurred. Please try again.',
            unableToAddFace: 'An error occurred and the frame could not be added.',
            unableToDeleteFace: 'An error occurred and the frame could not be deleted.',
            unableToRestoreFace: 'An error occured and the frame could not be restored.',
            unknown: 'Unknown', 
          },
      ia: { 
            confirmDeleteFace: 'Oday youway eallyray antway otay eleteday isthay amefray?',
            deleteFace: 'Eleteday Amefray',
            detailsButton: 'Etailsday', 
            errorApplyingChange: 'Anway errorway occurredway andway ethay angechay ouyay ademay ouldcay otnay ebay avedsay..',
            markPhoto: 'Arkmay or unmarkway isthay otophay orfay aterlay attentionway',
            photoButton: 'Otophay',
            restoreButton: 'Estoreray Amesfray',
            tryAgain: 'Anway errorway occurredway. Easeplay ytray againway.',
            unableToAddFace: 'Anway errorway occurredway andway ethay amefray ouldcay otnay ebay addedway.',
            unableToDeleteFace: 'Anway errorway occurredway andway ethay amefray ouldcay otnay ebay eletedday.', 
            unableToRestoreFace: 'Anway errorway occurredway andway ethay amefray ouldcay otnay ebay estoredray.', 
            unknown: 'Otnay Ownknay', 
          },
      };

    return {
      setLanguage: function(newLang)
      {
        language = newLang;
      },
      translate: function(key)
      {
        if (!translations[language])
        {
          return 'Missing language "' + language + '"';
        }
        if (!translations[language][key])
        {
          // TODO send an alert
          return 'Missing translation for "' + key + '"';
        }
        return translations[language][key];
      }
    };
  });

  // mmMovable: not really draggable (no drop needed), with a containment rectangle specified
  // derived from https://docs.angularjs.org/guide/directive (see "Creating a Directive that Adds Event Listeners")
  
  var calculateContainment = function(ele, behavior)
  {
    // All of the containment is in browser coordinates and is taken from the 
    // browser elements. This ensures that what the user sees is going to be
    // contained within the elements that are shown on the screen. Otherwise
    // there's a slight risk the browser display with be off by a pixel (or
    // a pixel-fraction on retina displays). I know that is un-angular in concept,
    // but that's how it works for now.

    var result;
    var photoEle = $('#photo-img');
    var photoWidth = photoEle.width();
    var photoHeight = photoEle.height();

    if (behavior == "move")
    {
      // The containment is a set of coordinates RELATIVE TO THE STARTING POSITION
      // of the top left corner of the frame, defining from that origin, how far
      // the the mouse can move (beyond which the mouse may move, but its motion is ignored).
      var frameEle = $(ele);
      result =  {
                  top:    0,
                  left:   0,
                  right:  photoEle.width() - frameEle.outerWidth(), 
                  bottom: photoEle.height() - frameEle.outerHeight(),
                }
    }
    else if (behavior == "resize")
    {
      // For this, the calculations are more complex. The "top" value is the smaller of
      // the distance from the top of the photo to the top of the frame and
      // the distance from the bottom of the photo and the bottom of the frame.
      // That number must then be subtracted from the starting position of the frame top.
      // The logic for the left is the same, except it involves the "x" axis.

      // The right and bottom points are the centerpoint of the frame.
      var frameEle = $(ele).parent();
      var framePos = frameEle.position();
      result =  {
                  top:    framePos.top - 
                          Math.min(framePos.top, photoEle.height() - (framePos.top + frameEle.outerHeight())),
                  left:   framePos.left - 
                          Math.min(framePos.left, photoEle.width() - (framePos.left + frameEle.outerWidth())),
                  right:  framePos.left + ((frameEle.width() - minFaceDimensionPixels) / 2),
                  bottom: framePos.top + ((frameEle.height() - minFaceDimensionPixels) / 2),
                };
      result.maxW = (2 * (result.right - result.left)) + minFaceDimensionPixels;
      result.maxH = (2 * (result.bottom - result.top)) + minFaceDimensionPixels;
    }
    else
    {
      console.log('Unexpected behavior ' + '"' + behavior + '"');
      return; 
    }
    result.constrainX = function(x) { return Math.min(Math.max(x, result.left), result.right); };
    result.constrainY = function(y) { return Math.min(Math.max(y, result.top), result.bottom); };
    result.constrainW = function(w) { return Math.min(Math.max(w, minFaceDimensionPixels), result.maxW); };
    result.constrainH = function(h) { return Math.min(Math.max(h, minFaceDimensionPixels), result.maxH); };
    return result;
  }

  app.directive('mmMovable', 
                [ '$document',
                  function($document, $scope)
                  {
                    return {
                      scope:
                      {
                        face: '=mmMovable',
                        behavior: '@mmMovableBehavior',
                        containment: '=mmMovableContainment',
                        photo: '=mmMovablePhoto'
                      },
                      link: function(scope, element, attr, ctrl) 
                      {
                        var containment; // Keeps track of where the top-left corner of the frame can move to.

                        // These the starting position of the cursor at the mousedown event
                        var mouseX, mouseY;

                        // These are the starting position of the top-left corner of the face frame
                        // in the *photo* coordinate space.
                        var initialX, initialY, initialH, initialW;
                        
                        element.on('mousedown', function(event) {
                          event.preventDefault(); // Prevent default dragging of selected content
                          event.stopPropagation(); // The handle is nested in the frame, so it fires 2x
                          if (scope.face.manual) // Otherwise the "move" option remains available to all faces
                          {
                            mouseX = event.pageX;
                            mouseY = event.pageY;
                            initialX = scope.photo.scaled(scope.face.x);
                            initialY = scope.photo.scaled(scope.face.y);
                            initialW = scope.photo.scaled(scope.face.w);
                            initialH = scope.photo.scaled(scope.face.h);

                            containment = calculateContainment(element, scope.behavior);

                            $document.on('mousemove', mousemove);
                            $document.on('mouseup', mouseup);           
                          }
                        });

                        function mousemove(event) {
                          var newX, newY, newW, newH;
                          var deltaX = event.pageX - mouseX;
                          var deltaY = event.pageY - mouseY;

                          if (scope.behavior == 'resize')
                          {
                            newX = initialX - (event.pageX - mouseX);
                            newY = initialY - (event.pageY - mouseY);
                            newX = containment.constrainX(newX);
                            newY = containment.constrainY(newY);
                            scope.face.x = scope.photo.unscaled(newX);
                            scope.face.y = scope.photo.unscaled(newY);

                            newW = initialW + (2 * (event.pageX - mouseX));
                            newH = initialH + (2 * (event.pageY - mouseY));
                            newW = containment.constrainW(newW);
                            newH = containment.constrainH(newH);
                            scope.face.w = scope.photo.unscaled(newW);
                            scope.face.h = scope.photo.unscaled(newH);
                          }
                          else if (scope.behavior == 'move')
                          {
                            newX = initialX + event.pageX - mouseX;
                            newY = initialY + event.pageY - mouseY;
                            newX = containment.constrainX(newX);
                            newY = containment.constrainY(newY);
                            scope.face.x = scope.photo.unscaled(newX);
                            scope.face.y = scope.photo.unscaled(newY);
                          }

                          scope.$apply();
                        }

                        function mouseup() {
                          $document.off('mousemove', mousemove);
                          $document.off('mouseup', mouseup);
                        }
                      }
                    };
                  }
                ]
  );

  // mmNameEntry: support the entry of a name from the specified elment by obscuring it
  // with the #name field.
  
  app.directive('mmNameEntry', 
                [ 'NameToPhotoGlue',
                  function(NameToPhotoGlue)
                  {
                    return {
                      scope:
                      {
                        face: '=mmNameEntry',
                      },
                      link: function(scope, element, attr, ctrl) 
                      {
                        var ele = element[0]; // extract the actual element
                        element.on('click', function(event)
                                            {
                                              NameToPhotoGlue.setFace(scope.face);
                                              var targetPosition = $(ele).offset();
                                              targetPosition.top -= 2;  // $borderWidth
                                              targetPosition.left -= 2; // $borderWidth

                                              // TODO It would be much better to clear the value of the
                                              // #name field by setting the nameNeedle to ''
                                              $('#name').val('').css(targetPosition).show();
                                              $('#name-entry-box').focus();
                                            });
                      }
                    }
                  }
                ]
  );
  /*

    // ***** Everything from this point down has to do with resizing/moving faces ***** //
    // ***** Only faces that were manually created are allowed to perform these functions ***** //

    var faceOriginalW;
    var faceOriginalH;
    var relPos;

    var setRelPos = function()
    {
      faceOriginalW = Math.floor(0.5 + $(face).width()); // round it up/down
      faceOriginalH = Math.floor(0.5 + $(face).height()); // round it up/down
      facePosition = $(face).position();
      relPos = {top: Math.floor(0.5 + facePosition.top) + faceOriginalH - handleRadius + borderWidth, 
                left: Math.floor(0.5 + facePosition.left) + faceOriginalW - handleRadius + borderWidth};
    }

    setRelPos();

    var setHandleContainmentRectangle = function(target)
    {
      var faceCenterX = containerPosition.left + facePosition.left + (faceOriginalW / 2);
      var faceCenterY = containerPosition.top + facePosition.top + (faceOriginalH / 2);
      var distanceToEachEdge = [faceCenterX - containerPosition.left, 
                                containerPosition.left + $('#photo-container > img').width() - faceCenterX];
      var maxDeltaX = Math.min.apply(null, distanceToEachEdge);
      distanceToEachEdge = [faceCenterY - containerPosition.top, 
                            containerPosition.top + $('#photo-container > img').height() - faceCenterY];
      var maxDeltaY = Math.min.apply(null, distanceToEachEdge);
      var handleContainment = [faceCenterX, // Do not adjust because handle is positioned from its left edge
                               faceCenterY,
                               faceCenterX + maxDeltaX - handleWidth,
                               faceCenterY + maxDeltaY - handleWidth
                              ];
      $(target).draggable('option', 'containment', handleContainment); 
    }
    var setFaceContainmentRectangle = function(target)
    {
      var faceContainmentRectangle = [containerPosition.left + handleRadius, 
                                      containerPosition.top + handleRadius,
                                      containerPosition.left + $('#photo-container > img').width() -
                                        ($(face).width() + handleWidth),
                                      containerPosition.top + $('#photo-container > img').height() -
                                        ($(face).height() + handleWidth)];
      $(target).draggable('option', 'containment', faceContainmentRectangle)
    }
  */
  app.controller('DetailController', 
                  ['$scope', '$stateParams', '$http', 'translations', 
                    function($scope, $stateParams, $http, translations)
                    {
                      $http.get('#{details_api_v1_photos_path(format: :json)}?a_id=1&id=' + $stateParams.id )
                           .success(function(response)
                                    {
                                      $scope.photo = {id: $stateParams.id}; // To support navigation in partial
                                      $scope.details = response;
                                    })
                      $scope.detailsAsJson = function()
                      {
                        return angular.toJson($scope.details, true);
                      }
                      $scope.xlate = translations.translate;
                    }
  ]);



  (function() {

    var id_counter = 1;
    Object.defineProperty(Object.prototype, "__uniqueId", {
        writable: true
    });
    Object.defineProperty(Object.prototype, "mmuid", {
        get: function() {
            if (this && (this.__uniqueId == undefined))
                this.__uniqueId = id_counter++;
            return this.__uniqueId;
        }
    });
  })();

  var timers = {};
  debounce = function(obj, milliseconds, func)
  {
    var args = arguments;
    clearTimeout(timers[obj.mmuid]);
    timers[obj.mmuid] = setTimeout(function()
                             {
                               func.apply(obj, args);
                               timers[obj.mmuid] = null;
                             }, 
                             milliseconds);
  }

  app.controller('PhotoController',
                 ['$scope', '$stateParams', '$window', 'Photo', 'Face', 'NameToPhotoGlue', 'translations', 
                  function($scope, $stateParams, $window, Photo, Face, NameToPhotoGlue, translations)
                  {
                    NameToPhotoGlue.setPhotoScope($scope);
                    var maxDim = 500; // pixels
                    var scaleFactor; // updated when the Photo object is loaded
                    $scope.listeners = [];

                    var defineScaledMethods = function(whichFace)
                    {
                      whichFace.scaledX = function() {return (this.x * scaleFactor) + 'px';};
                      whichFace.scaledY = function() {return (this.y * scaleFactor) + 'px';};
                      whichFace.scaledW = function() {return (this.w * scaleFactor) + 'px';};
                      whichFace.scaledH = function() {return (this.h * scaleFactor) + 'px';};
                      // "8" in the following has to do with the diameter of the handle
                      whichFace.handleY = function() {return (this.h * scaleFactor - 8) + 'px';};
                      whichFace.handleX = function() {return (this.w * scaleFactor - 8) + 'px';};
                      whichFace.thumbDataUri = function()
                                               {
                                                 if ((!this.thumbnail) || (this.thumbnail.length === 0))
                                                 {
                                                   return null;
                                                 }
                                                 else
                                                 {
                                                   return 'data:image/jpeg;base64,' + this.thumbnail;
                                                 }
                                               }
                      whichFace.displayName = NameToPhotoGlue.getPrivateName(whichFace.namedFaceId);
                      whichFace.photoId = photo.id;
                      whichFace.mmuid   // Assign a unique ID so the first debounce does not trigger an update
                      var listener = $scope.$watch('photo.faces[' + $scope.listeners.length + ']', 
                                                   faceResizeMoveOrNameChange,
                                                   true);
                      $scope.listeners.push(listener); // Hold onto it so it is possible to unbind it.
                    };
                    var photo = Photo.get({ id: $stateParams.id }, function() {
                      scaleFactor = maxDim / Math.max(photo.width, photo.height);

                      // "unscaled()" converts from browser coordinates to photo coordinates
                      photo.unscaled = function(rawValue) {return Math.floor(rawValue / scaleFactor);}

                      // "scaled()" converts from photo coordinates to browser coordinates
                      photo.scaled =   function(rawValue) {return Math.floor(rawValue * scaleFactor);}
                      photo.workingImageHeight = function() {return photo.height * scaleFactor + 'px'};
                      photo.workingImageWidth  = function() {return photo.width * scaleFactor + 'px'};
                      photo.mmuid; // Assign a unique ID so the first debounce does not trigger an update
                      angular.forEach(photo.faces, defineScaledMethods);                              
                      $scope.photo = photo;

                    }); // get() returns a single photo

                    $scope.addFaceAt = function(x, y)
                    {
                      // We must convert the coordinates back to that of the original photo
                      var unscaledX = $scope.photo.unscaled(x);
                      var unscaledY = $scope.photo.unscaled(y);

                      // We calculate the average width and height of visible faces
                      var sumW = 0;
                      var sumH = 0;
                      var defaultFaceDimension = Math.min($scope.photo.width, $scope.photo.height) / 10;
                      var meanWidth = minFaceDimension;
                      var meanHeight = minFaceDimension;
                      var n = 0;
                      var fs = $scope.photo.faces
                      for (var i = 0; i < fs.length; i++)
                      {
                        // Skip the logically deleted faces
                        if (!fs[i].deleted)
                        {
                          sumW += fs[i].w;
                          sumH += fs[i].h;
                          n += 1;
                        }
                      }
                      if (n > 0)
                      {
                        meanWidth = sumW / n;
                        meanHeight = sumH / n;
                      }
                      else
                      {
                        meanWidth = defaultFaceDimension;
                        meanHeight = defaultFaceDimension;
                      }

                      meanWidth = Math.max(meanWidth, minFaceDimension);
                      meanHeight = Math.max(meanHeight, minFaceDimension);
                      var face = {
                                  x: unscaledX - (meanWidth / 2), 
                                  y: unscaledY - (meanHeight / 2), 
                                  w: meanWidth, 
                                  h: meanHeight, 
                                  photoId: $scope.photoId,
                                  deleted: false,
                                  manual: true, 
                                  id: null,
                                  namedFaceId: null,
                                };
                      defineScaledMethods(face);
                      if ((0 < face.x) && (face.x < ($scope.photo.width - (meanWidth / 2))) &&
                          (0 < face.y) && (face.y < ($scope.photo.height - (meanHeight / 2))))
                      {
                        $scope.photo.faces.push(face);
                        Face.save(face, 
                                  function(data)
                                  {
                                    NameToPhotoGlue.mergeNewFacedata(data.names);
                                    face.id = data.face.id;
                                  },
                                  function(err)
                                  {
                                    $scope.removeFaceWithId(null);
                                    $window.alert($scope.xlate('unableToAddFace'));
                                  });
                      }
                      else
                      {
                        // TODO ...
                      }
                    }
                    $scope.noThumbnail = function(face)
                                         {
                                           return !(face.thumbnail === null || face.thumbnail.trim().length === 0)
                                         }
                    $scope.removeFaceWithId = function(targetId)
                                              {
                                                var matchingIndex;
                                                angular.forEach($scope.photo.faces, function(f, index)
                                                {
                                                  if (f.id == targetId)
                                                  {
                                                    matchingIndex = index;
                                                  }
                                                });
                                                if (matchingIndex)
                                                { 
                                                  // When we actually delete face (for real), we have to unbind
                                                  // the listener corresponding to the last array element, because
                                                  // the watch expressions are strings, for "face[i]", so when 
                                                  // there is one less, the last listener goes away.
                                                  var lastListener = $scope.listeners.pop();
                                                  lastListener();  // Unbind

                                                  // Now remove the particular face
                                                  $scope.photo.faces.splice(matchingIndex, 1);
                                                }
                                              }
                    $scope.restoreFace = function(face)
                                         {
                                           Face.restore({photo_id: face.photoId, id: face.id},
                                                        function(data)
                                                        {
                                                          NameToPhotoGlue.mergeNewFacedata(data.names);
                                                          face.deleted = data.face.deleted; // FALSE
                                                        },
                                                        function(err)
                                                        {
                                                          $window.alert($scope.xlate('unableToRestoreFace'));
                                                        });
                                         };
                    $scope.confirmFaceDeletion = function(face)
                                                  {
                                                    // We bypass the confirmation if it's both 
                                                    // unnamed and manually created.
                                                    if ((face.manual && !face.namedFaceId) ||
                                                        confirm($scope.xlate('confirmDeleteFace')))
                                                    {
                                                      Face.delete({photo_id: face.photoId, id: face.id},
                                                                  function(data)
                                                                  {
                                                                    NameToPhotoGlue.mergeNewFacedata(data.names);
                                                                    if (data.face.destroyed) // true deletion
                                                                    {
                                                                      $scope.removeFaceWithId(face.id);
                                                                    }
                                                                    else
                                                                    {
                                                                      face.deleted = data.face.deleted; // TRUE
                                                                    }
                                                                  },
                                                                  function(err)
                                                                  {
                                                                    $window.alert($scope.xlate('unableToDeleteFace'));
                                                                  });
                                                      $scope.setHoverFace(null);
                                                    }
                                                  }
                    $scope.handleVisible = function()
                                           {
                                             return true;
                                           }
                    $scope.setHoverFace = function(face, delay) // no delay param -> immediate update
                                          {
                                            // If a face is specified, show it right away.
                                            // If it is not, start a timer and clear it a second later.
                                            if ($scope.hoverTimer) // If there is a timer running, clear it first
                                            {
                                              clearTimeout($scope.hoverTimer);
                                              $scope.hoverTimer = undefined;
                                            }
                                            if (!delay)
                                            {
                                              $scope.hoverFace = face;
                                            }
                                            else
                                            {
                                              $scope.hoverTimer = setTimeout(function()
                                                                             {
                                                                                $scope.hoverFace = face;
                                                                                $scope.$apply();
                                                                              },
                                                                              delay);
                                            }
                                          }
                    $scope.setHoverFace(null);
                    $scope.xlate = translations.translate;

                    // If updateFace is called with one argument, then the 
                    // server will be updated with all the various values stored
                    // in the object. When called with a second argument (that is
                    // a string), it attempt to create a new FaceName and assign
                    // it to this face.
                    $scope.updateFace = function(face, newName)
                    {
                        var data = {
                                      photoId: face.photoId,
                                      id: face.id,
                                      x: face.x,
                                      y: face.y,
                                      width: face.w,
                                      height: face.h
                                    };
                        if (typeof newName == 'string')
                        {
                          data.newName = newName;
                        }
                        else
                        {
                          data.namedFaceId = face.namedFaceId;
                        }
                        Face.update(data,
                                    function(data)
                                    {
                                      face.namedFaceId = data.face.namedFaceId;
                                      NameToPhotoGlue.mergeNewFacedata(data.names);
                                      face.displayName = NameToPhotoGlue.getPrivateName(face.namedFaceId);
                                      $scope.setHoverFace(null, 1200); // Leave a little time for them to see it.
                                    },
                                    function(err)
                                    {
                                      $window.alert($scope.xlate('errorApplyingChange'));
                                      $scope.setHoverFace(null);
                                    });
                    }
                    var faceResizeMoveOrNameChange = function(newValue, oldValue)
                    {
                      if (newValue) // It is undefined after a delete operation
                      {
                        // We only monitor x and y, as any move or resize operation
                        // must change at least one if not both of them.
                        if ((newValue.x != oldValue.x) || (newValue.y != oldValue.y))
                        {
                          debounce(newValue, 1500, $scope.updateFace)
                        }
                        else if (newValue.namedFaceId != oldValue.namedFaceId)
                        {
                          debounce(newValue, 100, $scope.updateFace)
                        }
                      }
                    }
                  }
                ]
  );

  app.controller('NamesController', 
                 ['$scope', '$http', '$window', 'NameToPhotoGlue', 'translations', 
                  function($scope, $http, $window, NameToPhotoGlue, translations)
                  {
                    $http.get("#{api_v1_names_path}.json?a_id=1")
                         .success(function(response)
                                  { 
                                     $scope.names = response;
                                     NameToPhotoGlue.setNamesIndex($scope.names);
                                  }
                         );
                    $scope.nameNeedle = '';
                    $scope.hideNameEntry = function()
                                           {
                                             $('#name').hide();
                                           }
                    $scope.setSelectedName = function(name)
                                             {
                                               NameToPhotoGlue.setName(name);
                                               $scope.hideNameEntry();
                                             }
                    $scope.xlate = translations.translate;
                    $scope.processKeydown = function(keyboardEvent)
                    {
                      if ((keyboardEvent.keyCode == 40) ||  // down
                          (keyboardEvent.keyCode == 38))
                      {
                        // We have to intercept these on the down, otherwise
                        // they perform field beginning/end cursor movements.
                        event.preventDefault();
                      }
                    }
                    $scope.processKeyup = function(keyboardEvent)
                    {
                      var key = keyboardEvent.which;
                      if (key == 27) // escape
                      {
                        $scope.hideNameEntry();
                      }
                      else if (key == 13) // return/enter
                      {
                        if (confirm('new name?'))
                        {
                          NameToPhotoGlue.applyNewName($scope.nameNeedle);
                          $scope.nameNeedle = '';
                        }
                        $scope.hideNameEntry();
                      }
                      keyboardEvent.stopPropagation()
                    }
                  }
                ]
  );

  app.filter('matchesNameNeedle', 
              function ()
              {
                return function (name) {
                    return name.publicName.toUpperCase();
                };
              }
  );


-# // ***** This is all the markup for the page *****

%nav.navbar.navbar-default.navbar-fixed-top
  .container
    .navbar-header
      %button.navbar-toggle.collapsed{'type' => 'button',  |
                                      'data-toggle' => "collapse",  |
                                      'data-target' => "#navbar",   |
                                      'aria-expanded' => "false",   |
                                      'aria-controls' => 'navbar' }
        %span.sr-only
          Toggle navigation
        %span.icon-bar
        %span.icon-bar
        %span.icon-bar
      %a.navbar-brand{href: '#'}
        mugmarker
    .navbar.navbar-collapse.collapse
      %ul.nav.navbar-nav
        %li
          %a{href: '/go/1#/photos'}
            Photos
        %li
          %a{href: '/go/1#/faces'}
            Faces
      %ul.nav.navbar-nav.navbar-right
        %li.dropdown
          %a.dropdown-toggle{href: '#',
                             'data-toggle' => "dropdown",
                             'role' => "button",
                             'aria-expanded' => "false"}
            menu
            %span.caret
          %ul.dropdown-menu{role: 'menu'}
            %li
              %a{href: '#'}
                Settings
            %li
              %a{href: '#'}
                Log In
            %li
              %a{href: '#'}
                Log Out
            %li.dropdown

.container
  .row#photobar-container
    #photobar

.container{'ui-view' => 'display'}

#name{style: 'display: none; padding: 0; position:absolute;', 'ng-controller' => 'NamesController'}
  .icon-control{style: 'position: absolute; right: -5px;'}
    %span#name-dismiss.glyphicon.glyphicon-remove{"aria-label" => "Clear the name input field", |
                                                  :style => "top: -10px; background-color: black; color: white;", |
                                                  'ng-click' => 'hideNameEntry()'}

  %form#name-entry-form{novalidate: :novalidate, :style => "width: 20em;"}
    %input#name-entry-box.form-control.input-sm{'ng-model' => "nameNeedle",
                                                'ng-keydown' => "processKeydown($event)",
                                                'ng-keyup' => "processKeyup($event)",
                                                :placeholder => "Enter Name",
                                                :type => "text"}/
  #names-container.dropdown-menu{:style => "margin-top: 0; padding-top: 5px; width: 20em; max-height: 170px; display: block;"}
    .row{'ng-repeat' => '(id, name) in names', 
         'ng-click' => 'setSelectedName(name)',
         'ng-show' => '(name.publicName.toLowerCase().indexOf(nameNeedle.toLowerCase()) > -1) || (name.note.toLowerCase().indexOf(nameNeedle.toLowerCase()) > -1)'}
      .col-xs-1{:style => "padding-left: 4px; min-width: 38px; "}
        %img{:src => "https://upload.wikimedia.org/wikipedia/en/6/6f/Smiley_Face.png", :style => "height:30px"}/
      .col-xs-10.ellipsis{:style => "padding: 0;"}
        {{ name.publicName }}
        .name-note
          {{ name.note ? name.note : 'Â ' }}

:javascript

  // ***** All the ISOLATED jQuery-dependent stuff that has to come after jQuery is loaded
  //       and the DOM is ready. Hence it is at the end, isolated. Move this to jqLite.    *****
  var i2x = function(i) { return endGap + (i * photoWidth) };
  var x2i = function(x) { return Math.floor(Math.max(0, x - endGap) / photoWidth) };
  
  // This is the number of requests to make. It relies on knowing how many total photos there are,
  // so we scale it back after the first request. It starts big in case the window is super-wide.
  var photosPerRequest = 20;
  var photobarContainerWidth = document.getElementById('photobar-container').offsetWidth;
  var bunchedRequestCount = (photobarContainerWidth / (photosPerRequest * photoWidth)) + 1;

      // TODO  Add code so we don't fetch the same bunch of photos if it's already displayed
      // TODO  Add code to purge photos when the DOM element starts to get full.
      // TODO  There was code here to make sure it doesn't show the same photo twice:
      //  <% if ($('.photothumb[phid=' + photo.get('id') + ']').length == 0) { %>

  var jqLite = angular.element;
  var jqLiteFind = function(sel) { angular.element(document.querySelector(sel)) };
  var getNavImages = function(i)
  {
    $.ajax({
      url: 'http://localhost:3000/api/v1/photos.json?a_id=1&n=' + photosPerRequest + '&i=' + i,
      success: function(response)
               {
                 document.getElementById('photobar').style.width = i2x(response.totalPhotos) + 'px';
                 for (var i = 0; i < response.photos.length ; i++) 
                 {
                   var photo = response.photos[i];
                   var match = document.getElementById('thumb_' + photo.id);
                   if (!match)
                   {
                     photo.aspectRatio = photo.width / photo.height;
                     var thumbStyle = (photo.aspectRatio > 1) ? 'width: ' + fullThumbSize + 'px; height: ' + (fullThumbSize / photo.aspectRatio) + 'px;' 
                                                              : 'width: ' + (fullThumbSize * photo.aspectRatio) + 'px; height: ' + fullThumbSize + 'px;' ;
                     $('<div id="thumb_' + photo.id + '" ' +
                                 'class="photothumb unselected" ' +
                                 'style="left:' + i2x(photo.index) + 'px;" '  +
                                 'data-index="' + photo.index + '" ' +
                                 'data-id="' + photo.id + '"><img src="'+ 
                                 photo.thumb + '" style="' + thumbStyle + '" /></div>')
                       .appendTo('#photobar');
                   }
                 }
               },
        error: function(jqXhr, status) {
            alert('An unexpected error occurred (' + status + '). Please try again.');
          },
        dataType: 'json'
    });
  }
  
  var scrollingDone = function() {
    var x = document.getElementById('photobar-container').scrollLeft;
    n = Math.floor(x2i(x) / photosPerRequest); // The first bunch to be requested
    for (var j = 0; j < bunchedRequestCount; j++)
    {
      getNavImages(n + j);
    }
  };
  scrollingDone();
  $('#photobar-container').on('scroll', function() {debounce(this, 250, scrollingDone)} );

  $('#photobar').on('mouseover', '.photothumb', function() {
      $(this).css({ top: $(this).position().top - halfThumbSize,
                    left: $(this).position().left - halfThumbSize
                  });
  });
  $('#photobar').on('mouseout', '.photothumb', function() {
    $(this).css({ top:  $(this).position().top + halfThumbSize,
                  left: $(this).position().left + halfThumbSize
                 });
  });
  $('#photobar').on('click', '.photothumb', function() {
    $('#photobar > .selected').removeClass('selected').addClass('unselected');
    // TODO Fill in with the image you have. Requires knowing the AR of the photo 
    //$('#photo-container').html('&nbsp;').css({'background-image': $(this).css('background-image'), 
    //                                            "background-size": "contain", 
    //                                            "background-color": "white"})
    //                                      .css(parseFloat($(this).attr("ar")) > 1.0 ? 'width' : 'height', "500px");
    $(this).removeClass('unselected').addClass('selected');
    window.location = "#/photo/edit/" + $(this).data('id');
  });
  $(document).on('keyup', function(keyboardEvent) {
    var key = keyboardEvent.which;
    var current = $('#photobar > .selected').data('index');
    if (current)
    {
      if (key == 37) // left arrow
      {
        current -= 1;
      }
      else if (key == 39) // right arrow
      {
        current += 1;
      }
      var next = $('#photobar > div[data-index=' + current + ']');
      console.log('next', next);
      next.trigger('click');
    }
  });
